package base

import (
	context "context"
	fmt "fmt"
	errors "github.com/RahkarSanat/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	gorm "gorm.io/gorm"
)

type ArchiveFindOneResponseORM struct {
	Clients   []string `gorm:"type:Array(String);not null"`
	CreatedAt *uint64
	CreatedBy *string
	CreatedIn *string
	Data      []byte `gorm:"type:bytea;not null"`
	Id        string
	Owner     *string
	Relations []string `gorm:"type:Array(String);not null"`
	Shares    []string `gorm:"type:Array(String);not null"`
	Version   *string
	Zones     []string `gorm:"type:Array(String);not null"`
}

// TableName overrides the default tablename generated by GORM
func (ArchiveFindOneResponseORM) TableName() string {
	return "archive_find_one_responses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ArchiveFindOneResponse) ToORM(ctx context.Context) (ArchiveFindOneResponseORM, error) {
	to := ArchiveFindOneResponseORM{}
	var err error
	if prehook, ok := interface{}(m).(ArchiveFindOneResponseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Owner = m.Owner
	if m.Clients != nil {
		to.Clients = make([]string, len(m.Clients))
		for k, v := range m.Clients {
			to.Clients[k] = v
		}
	}
	if m.Zones != nil {
		to.Zones = make([]string, len(m.Zones))
		for k, v := range m.Zones {
			to.Zones[k] = v
		}
	}
	if m.Relations != nil {
		to.Relations = make([]string, len(m.Relations))
		for k, v := range m.Relations {
			to.Relations[k] = v
		}
	}
	if m.Shares != nil {
		to.Shares = make([]string, len(m.Shares))
		for k, v := range m.Shares {
			to.Shares[k] = v
		}
	}
	to.CreatedBy = m.CreatedBy
	to.CreatedAt = m.CreatedAt
	to.CreatedIn = m.CreatedIn
	to.Version = m.Version
	to.Data = m.Data
	if posthook, ok := interface{}(m).(ArchiveFindOneResponseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ArchiveFindOneResponseORM) ToPB(ctx context.Context) (ArchiveFindOneResponse, error) {
	to := ArchiveFindOneResponse{}
	var err error
	if prehook, ok := interface{}(m).(ArchiveFindOneResponseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Owner = m.Owner
	if m.Clients != nil {
		to.Clients = make([]string, len(m.Clients))
		for k, v := range m.Clients {
			to.Clients[k] = v
		}
	}
	if m.Zones != nil {
		to.Zones = make([]string, len(m.Zones))
		for k, v := range m.Zones {
			to.Zones[k] = v
		}
	}
	if m.Relations != nil {
		to.Relations = make([]string, len(m.Relations))
		for k, v := range m.Relations {
			to.Relations[k] = v
		}
	}
	if m.Shares != nil {
		to.Shares = make([]string, len(m.Shares))
		for k, v := range m.Shares {
			to.Shares[k] = v
		}
	}
	to.CreatedBy = m.CreatedBy
	to.CreatedAt = m.CreatedAt
	to.CreatedIn = m.CreatedIn
	to.Version = m.Version
	to.Data = m.Data
	if posthook, ok := interface{}(m).(ArchiveFindOneResponseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ArchiveFindOneResponse the arg will be the target, the caller the one being converted from

// ArchiveFindOneResponseBeforeToORM called before default ToORM code
type ArchiveFindOneResponseWithBeforeToORM interface {
	BeforeToORM(context.Context, *ArchiveFindOneResponseORM) error
}

// ArchiveFindOneResponseAfterToORM called after default ToORM code
type ArchiveFindOneResponseWithAfterToORM interface {
	AfterToORM(context.Context, *ArchiveFindOneResponseORM) error
}

// ArchiveFindOneResponseBeforeToPB called before default ToPB code
type ArchiveFindOneResponseWithBeforeToPB interface {
	BeforeToPB(context.Context, *ArchiveFindOneResponse) error
}

// ArchiveFindOneResponseAfterToPB called after default ToPB code
type ArchiveFindOneResponseWithAfterToPB interface {
	AfterToPB(context.Context, *ArchiveFindOneResponse) error
}

type BaseAccessORM struct {
	Clients    []*string `gorm:"type:Array(String)"`
	CreatedBy  *string
	DeletedBy  *string
	Id         string `gorm:"type:UUID;primaryKey"`
	Owner      string
	Relations  []*string `gorm:"type:Array(String)"`
	RestoredBy *string
	Shares     []*string `gorm:"type:Array(String)"`
	UpdatedBy  *string
	Zones      []*string `gorm:"type:Array(String)"`
}

// TableName overrides the default tablename generated by GORM
func (BaseAccessORM) TableName() string {
	return "base_accesses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BaseAccess) ToORM(ctx context.Context) (BaseAccessORM, error) {
	to := BaseAccessORM{}
	var err error
	if prehook, ok := interface{}(m).(BaseAccessWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Owner = m.Owner
	if m.Zones != nil {
		for _, v := range m.Zones {
			to.Zones = append(to.Zones, &v)
		}
	}
	if m.Clients != nil {
		for _, v := range m.Clients {
			to.Clients = append(to.Clients, &v)
		}
	}
	if m.Shares != nil {
		for _, v := range m.Shares {
			to.Shares = append(to.Shares, &v)
		}
	}
	if m.Relations != nil {
		for _, v := range m.Relations {
			to.Relations = append(to.Relations, &v)
		}
	}
	to.CreatedBy = m.CreatedBy
	to.UpdatedBy = m.UpdatedBy
	to.DeletedBy = m.DeletedBy
	to.RestoredBy = m.RestoredBy
	if posthook, ok := interface{}(m).(BaseAccessWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BaseAccessORM) ToPB(ctx context.Context) (BaseAccess, error) {
	to := BaseAccess{}
	var err error
	if prehook, ok := interface{}(m).(BaseAccessWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Owner = m.Owner
	if m.Zones != nil {
		for _, v := range m.Zones {
			if v != nil {
				to.Zones = append(to.Zones, *v)
			}
		}
	}
	if m.Clients != nil {
		for _, v := range m.Clients {
			if v != nil {
				to.Clients = append(to.Clients, *v)
			}
		}
	}
	if m.Shares != nil {
		for _, v := range m.Shares {
			if v != nil {
				to.Shares = append(to.Shares, *v)
			}
		}
	}
	if m.Relations != nil {
		for _, v := range m.Relations {
			if v != nil {
				to.Relations = append(to.Relations, *v)
			}
		}
	}
	to.CreatedBy = m.CreatedBy
	to.UpdatedBy = m.UpdatedBy
	to.DeletedBy = m.DeletedBy
	to.RestoredBy = m.RestoredBy
	if posthook, ok := interface{}(m).(BaseAccessWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BaseAccess the arg will be the target, the caller the one being converted from

// BaseAccessBeforeToORM called before default ToORM code
type BaseAccessWithBeforeToORM interface {
	BeforeToORM(context.Context, *BaseAccessORM) error
}

// BaseAccessAfterToORM called after default ToORM code
type BaseAccessWithAfterToORM interface {
	AfterToORM(context.Context, *BaseAccessORM) error
}

// BaseAccessBeforeToPB called before default ToPB code
type BaseAccessWithBeforeToPB interface {
	BeforeToPB(context.Context, *BaseAccess) error
}

// BaseAccessAfterToPB called after default ToPB code
type BaseAccessWithAfterToPB interface {
	AfterToPB(context.Context, *BaseAccess) error
}

type BasePropertiesORM struct {
	CreatedIn  *string
	DeletedIn  *string
	Id         string `gorm:"type:UUID;primaryKey"`
	RestoredIn *string
	Tags       []*string `gorm:"type:Array(String)"`
	UpdatedIn  *string
	Version    *int32
}

// TableName overrides the default tablename generated by GORM
func (BasePropertiesORM) TableName() string {
	return "base_properties"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BaseProperties) ToORM(ctx context.Context) (BasePropertiesORM, error) {
	to := BasePropertiesORM{}
	var err error
	if prehook, ok := interface{}(m).(BasePropertiesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedIn = m.CreatedIn
	to.UpdatedIn = m.UpdatedIn
	to.DeletedIn = m.DeletedIn
	to.RestoredIn = m.RestoredIn
	if m.Tags != nil {
		for _, v := range m.Tags {
			to.Tags = append(to.Tags, &v)
		}
	}
	to.Version = m.Version
	if posthook, ok := interface{}(m).(BasePropertiesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BasePropertiesORM) ToPB(ctx context.Context) (BaseProperties, error) {
	to := BaseProperties{}
	var err error
	if prehook, ok := interface{}(m).(BasePropertiesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedIn = m.CreatedIn
	to.UpdatedIn = m.UpdatedIn
	to.DeletedIn = m.DeletedIn
	to.RestoredIn = m.RestoredIn
	if m.Tags != nil {
		for _, v := range m.Tags {
			if v != nil {
				to.Tags = append(to.Tags, *v)
			}
		}
	}
	to.Version = m.Version
	if posthook, ok := interface{}(m).(BasePropertiesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BaseProperties the arg will be the target, the caller the one being converted from

// BasePropertiesBeforeToORM called before default ToORM code
type BasePropertiesWithBeforeToORM interface {
	BeforeToORM(context.Context, *BasePropertiesORM) error
}

// BasePropertiesAfterToORM called after default ToORM code
type BasePropertiesWithAfterToORM interface {
	AfterToORM(context.Context, *BasePropertiesORM) error
}

// BasePropertiesBeforeToPB called before default ToPB code
type BasePropertiesWithBeforeToPB interface {
	BeforeToPB(context.Context, *BaseProperties) error
}

// BasePropertiesAfterToPB called after default ToPB code
type BasePropertiesWithAfterToPB interface {
	AfterToPB(context.Context, *BaseProperties) error
}

type BaseDatesORM struct {
	CreatedAt  *string `gorm:"type:DateTime"`
	DeletedAt  *string `gorm:"type:DateTime"`
	Id         string  `gorm:"type:UUID;primaryKey"`
	RestoredAt *string `gorm:"type:DateTime"`
	UpdatedAt  *string `gorm:"type:DateTime"`
}

// TableName overrides the default tablename generated by GORM
func (BaseDatesORM) TableName() string {
	return "base_dates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BaseDates) ToORM(ctx context.Context) (BaseDatesORM, error) {
	to := BaseDatesORM{}
	var err error
	if prehook, ok := interface{}(m).(BaseDatesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.DeletedAt = m.DeletedAt
	to.RestoredAt = m.RestoredAt
	if posthook, ok := interface{}(m).(BaseDatesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BaseDatesORM) ToPB(ctx context.Context) (BaseDates, error) {
	to := BaseDates{}
	var err error
	if prehook, ok := interface{}(m).(BaseDatesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.DeletedAt = m.DeletedAt
	to.RestoredAt = m.RestoredAt
	if posthook, ok := interface{}(m).(BaseDatesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BaseDates the arg will be the target, the caller the one being converted from

// BaseDatesBeforeToORM called before default ToORM code
type BaseDatesWithBeforeToORM interface {
	BeforeToORM(context.Context, *BaseDatesORM) error
}

// BaseDatesAfterToORM called after default ToORM code
type BaseDatesWithAfterToORM interface {
	AfterToORM(context.Context, *BaseDatesORM) error
}

// BaseDatesBeforeToPB called before default ToPB code
type BaseDatesWithBeforeToPB interface {
	BeforeToPB(context.Context, *BaseDates) error
}

// BaseDatesAfterToPB called after default ToPB code
type BaseDatesWithAfterToPB interface {
	AfterToPB(context.Context, *BaseDates) error
}

// DefaultCreateArchiveFindOneResponse executes a basic gorm create call
func DefaultCreateArchiveFindOneResponse(ctx context.Context, in *ArchiveFindOneResponse, db *gorm.DB) (*ArchiveFindOneResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ArchiveFindOneResponseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadArchiveFindOneResponse(ctx context.Context, in *ArchiveFindOneResponse, db *gorm.DB) (*ArchiveFindOneResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ArchiveFindOneResponseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ArchiveFindOneResponseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ArchiveFindOneResponseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteArchiveFindOneResponse(ctx context.Context, in *ArchiveFindOneResponse, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ArchiveFindOneResponseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ArchiveFindOneResponseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteArchiveFindOneResponseSet(ctx context.Context, in []*ArchiveFindOneResponse, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ArchiveFindOneResponseORM{})).(ArchiveFindOneResponseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ArchiveFindOneResponseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ArchiveFindOneResponseORM{})).(ArchiveFindOneResponseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ArchiveFindOneResponseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ArchiveFindOneResponse, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ArchiveFindOneResponse, *gorm.DB) error
}

// DefaultStrictUpdateArchiveFindOneResponse clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateArchiveFindOneResponse(ctx context.Context, in *ArchiveFindOneResponse, db *gorm.DB) (*ArchiveFindOneResponse, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateArchiveFindOneResponse")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ArchiveFindOneResponseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ArchiveFindOneResponseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchArchiveFindOneResponse executes a basic gorm update call with patch behavior
func DefaultPatchArchiveFindOneResponse(ctx context.Context, in *ArchiveFindOneResponse, updateMask *field_mask.FieldMask, db *gorm.DB) (*ArchiveFindOneResponse, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ArchiveFindOneResponse
	var err error
	if hook, ok := interface{}(&pbObj).(ArchiveFindOneResponseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadArchiveFindOneResponse(ctx, &ArchiveFindOneResponse{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ArchiveFindOneResponseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskArchiveFindOneResponse(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ArchiveFindOneResponseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateArchiveFindOneResponse(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ArchiveFindOneResponseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ArchiveFindOneResponseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ArchiveFindOneResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ArchiveFindOneResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ArchiveFindOneResponse, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ArchiveFindOneResponse, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetArchiveFindOneResponse executes a bulk gorm update call with patch behavior
func DefaultPatchSetArchiveFindOneResponse(ctx context.Context, objects []*ArchiveFindOneResponse, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ArchiveFindOneResponse, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ArchiveFindOneResponse, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchArchiveFindOneResponse(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskArchiveFindOneResponse patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskArchiveFindOneResponse(ctx context.Context, patchee *ArchiveFindOneResponse, patcher *ArchiveFindOneResponse, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ArchiveFindOneResponse, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Owner" {
			patchee.Owner = patcher.Owner
			continue
		}
		if f == prefix+"Clients" {
			patchee.Clients = patcher.Clients
			continue
		}
		if f == prefix+"Zones" {
			patchee.Zones = patcher.Zones
			continue
		}
		if f == prefix+"Relations" {
			patchee.Relations = patcher.Relations
			continue
		}
		if f == prefix+"Shares" {
			patchee.Shares = patcher.Shares
			continue
		}
		if f == prefix+"CreatedBy" {
			patchee.CreatedBy = patcher.CreatedBy
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedIn" {
			patchee.CreatedIn = patcher.CreatedIn
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListArchiveFindOneResponse executes a gorm list call
func DefaultListArchiveFindOneResponse(ctx context.Context, db *gorm.DB) ([]*ArchiveFindOneResponse, error) {
	in := ArchiveFindOneResponse{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ArchiveFindOneResponseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ArchiveFindOneResponseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ArchiveFindOneResponse{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ArchiveFindOneResponseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ArchiveFindOneResponseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ArchiveFindOneResponseORM) error
}

// DefaultCreateBaseAccess executes a basic gorm create call
func DefaultCreateBaseAccess(ctx context.Context, in *BaseAccess, db *gorm.DB) (*BaseAccess, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BaseAccessORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBaseAccess(ctx context.Context, in *BaseAccess, db *gorm.DB) (*BaseAccess, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BaseAccessORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BaseAccessORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BaseAccessORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBaseAccess(ctx context.Context, in *BaseAccess, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BaseAccessORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BaseAccessORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBaseAccessSet(ctx context.Context, in []*BaseAccess, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BaseAccessORM{})).(BaseAccessORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BaseAccessORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BaseAccessORM{})).(BaseAccessORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BaseAccessORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BaseAccess, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BaseAccess, *gorm.DB) error
}

// DefaultStrictUpdateBaseAccess clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBaseAccess(ctx context.Context, in *BaseAccess, db *gorm.DB) (*BaseAccess, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBaseAccess")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BaseAccessORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BaseAccessORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBaseAccess executes a basic gorm update call with patch behavior
func DefaultPatchBaseAccess(ctx context.Context, in *BaseAccess, updateMask *field_mask.FieldMask, db *gorm.DB) (*BaseAccess, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BaseAccess
	var err error
	if hook, ok := interface{}(&pbObj).(BaseAccessWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBaseAccess(ctx, &BaseAccess{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BaseAccessWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBaseAccess(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BaseAccessWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBaseAccess(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BaseAccessWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BaseAccessWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BaseAccess, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BaseAccess, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BaseAccess, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BaseAccess, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBaseAccess executes a bulk gorm update call with patch behavior
func DefaultPatchSetBaseAccess(ctx context.Context, objects []*BaseAccess, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BaseAccess, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BaseAccess, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBaseAccess(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBaseAccess patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBaseAccess(ctx context.Context, patchee *BaseAccess, patcher *BaseAccess, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BaseAccess, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Owner" {
			patchee.Owner = patcher.Owner
			continue
		}
		if f == prefix+"Zones" {
			patchee.Zones = patcher.Zones
			continue
		}
		if f == prefix+"Clients" {
			patchee.Clients = patcher.Clients
			continue
		}
		if f == prefix+"Shares" {
			patchee.Shares = patcher.Shares
			continue
		}
		if f == prefix+"Relations" {
			patchee.Relations = patcher.Relations
			continue
		}
		if f == prefix+"CreatedBy" {
			patchee.CreatedBy = patcher.CreatedBy
			continue
		}
		if f == prefix+"UpdatedBy" {
			patchee.UpdatedBy = patcher.UpdatedBy
			continue
		}
		if f == prefix+"DeletedBy" {
			patchee.DeletedBy = patcher.DeletedBy
			continue
		}
		if f == prefix+"RestoredBy" {
			patchee.RestoredBy = patcher.RestoredBy
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBaseAccess executes a gorm list call
func DefaultListBaseAccess(ctx context.Context, db *gorm.DB) ([]*BaseAccess, error) {
	in := BaseAccess{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BaseAccessORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseAccessORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BaseAccess{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BaseAccessORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseAccessORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BaseAccessORM) error
}

// DefaultCreateBaseProperties executes a basic gorm create call
func DefaultCreateBaseProperties(ctx context.Context, in *BaseProperties, db *gorm.DB) (*BaseProperties, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BasePropertiesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBaseProperties(ctx context.Context, in *BaseProperties, db *gorm.DB) (*BaseProperties, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BasePropertiesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BasePropertiesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BasePropertiesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBaseProperties(ctx context.Context, in *BaseProperties, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BasePropertiesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BasePropertiesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBasePropertiesSet(ctx context.Context, in []*BaseProperties, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BasePropertiesORM{})).(BasePropertiesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BasePropertiesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BasePropertiesORM{})).(BasePropertiesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BasePropertiesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BaseProperties, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BaseProperties, *gorm.DB) error
}

// DefaultStrictUpdateBaseProperties clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBaseProperties(ctx context.Context, in *BaseProperties, db *gorm.DB) (*BaseProperties, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBaseProperties")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BasePropertiesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BasePropertiesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBaseProperties executes a basic gorm update call with patch behavior
func DefaultPatchBaseProperties(ctx context.Context, in *BaseProperties, updateMask *field_mask.FieldMask, db *gorm.DB) (*BaseProperties, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BaseProperties
	var err error
	if hook, ok := interface{}(&pbObj).(BasePropertiesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBaseProperties(ctx, &BaseProperties{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BasePropertiesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBaseProperties(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BasePropertiesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBaseProperties(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BasePropertiesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BasePropertiesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BaseProperties, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BaseProperties, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BaseProperties, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BaseProperties, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBaseProperties executes a bulk gorm update call with patch behavior
func DefaultPatchSetBaseProperties(ctx context.Context, objects []*BaseProperties, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BaseProperties, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BaseProperties, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBaseProperties(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBaseProperties patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBaseProperties(ctx context.Context, patchee *BaseProperties, patcher *BaseProperties, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BaseProperties, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedIn" {
			patchee.CreatedIn = patcher.CreatedIn
			continue
		}
		if f == prefix+"UpdatedIn" {
			patchee.UpdatedIn = patcher.UpdatedIn
			continue
		}
		if f == prefix+"DeletedIn" {
			patchee.DeletedIn = patcher.DeletedIn
			continue
		}
		if f == prefix+"RestoredIn" {
			patchee.RestoredIn = patcher.RestoredIn
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBaseProperties executes a gorm list call
func DefaultListBaseProperties(ctx context.Context, db *gorm.DB) ([]*BaseProperties, error) {
	in := BaseProperties{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BasePropertiesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BasePropertiesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BaseProperties{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BasePropertiesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BasePropertiesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BasePropertiesORM) error
}

// DefaultCreateBaseDates executes a basic gorm create call
func DefaultCreateBaseDates(ctx context.Context, in *BaseDates, db *gorm.DB) (*BaseDates, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BaseDatesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBaseDates(ctx context.Context, in *BaseDates, db *gorm.DB) (*BaseDates, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BaseDatesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BaseDatesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BaseDatesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBaseDates(ctx context.Context, in *BaseDates, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BaseDatesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BaseDatesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBaseDatesSet(ctx context.Context, in []*BaseDates, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BaseDatesORM{})).(BaseDatesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BaseDatesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BaseDatesORM{})).(BaseDatesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BaseDatesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BaseDates, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BaseDates, *gorm.DB) error
}

// DefaultStrictUpdateBaseDates clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBaseDates(ctx context.Context, in *BaseDates, db *gorm.DB) (*BaseDates, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBaseDates")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BaseDatesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BaseDatesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBaseDates executes a basic gorm update call with patch behavior
func DefaultPatchBaseDates(ctx context.Context, in *BaseDates, updateMask *field_mask.FieldMask, db *gorm.DB) (*BaseDates, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BaseDates
	var err error
	if hook, ok := interface{}(&pbObj).(BaseDatesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBaseDates(ctx, &BaseDates{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BaseDatesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBaseDates(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BaseDatesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBaseDates(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BaseDatesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BaseDatesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BaseDates, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BaseDates, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BaseDates, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BaseDates, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBaseDates executes a bulk gorm update call with patch behavior
func DefaultPatchSetBaseDates(ctx context.Context, objects []*BaseDates, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BaseDates, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BaseDates, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBaseDates(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBaseDates patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBaseDates(ctx context.Context, patchee *BaseDates, patcher *BaseDates, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BaseDates, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"RestoredAt" {
			patchee.RestoredAt = patcher.RestoredAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBaseDates executes a gorm list call
func DefaultListBaseDates(ctx context.Context, db *gorm.DB) ([]*BaseDates, error) {
	in := BaseDates{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BaseDatesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BaseDatesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BaseDates{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BaseDatesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BaseDatesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BaseDatesORM) error
}
